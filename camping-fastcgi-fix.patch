--- camping-o/lib/camping-unabridged.rb	2006-12-20 23:38:05.000000000 -0700
+++ camping-r168/lib/camping-unabridged.rb	2006-12-20 23:37:03.000000000 -0700
@@ -373,7 +373,7 @@
       @status, @method, @env, @headers, @root = 200, m.downcase, e, 
           {'Content-Type'=>'text/html'}, e.SCRIPT_NAME.sub(/\/$/,'')
       @k = C.kp(e.HTTP_COOKIE)
-      qs = C.qs_parse(e.QUERY_STRING)
+      qs = C.qsp(e.QUERY_STRING)
       @in = r
       if %r|\Amultipart/form-data.*boundary=\"?([^\";,]+)|n.match(e.CONTENT_TYPE)
         b = /(?:\r?\n|\A)#{Regexp::quote("--#$1")}(?:--)?\r$/
@@ -404,11 +404,11 @@
             end
             o<<l
           end
-          qs[fn]=fh if fn
+          C.qsp(fn,'&;',fh,qs) if fn
           fh[:tempfile].rewind if fh.is_a?H
         end
       elsif @method == "post"
-        qs.merge!(C.qs_parse(@in.read))
+        qs.merge!(C.qsp(@in.read))
       end
       @cookies, @input = @k.dup, qs.dup
     end
@@ -614,28 +614,28 @@
 
     # Parses a query string into an Camping::H object.
     #
-    #   input = Camping.qs_parse("name=Philarp+Tremain&hair=sandy+blonde")
+    #   input = Camping.qsp("name=Philarp+Tremain&hair=sandy+blonde")
     #   input.name
     #     #=> "Philarp Tremaine"
     #
     # Also parses out the Hash-like syntax used in PHP and Rails and builds
     # nested hashes from it.
     #
-    #   input = Camping.qs_parse("post[id]=1&post[user]=_why")
+    #   input = Camping.qsp("post[id]=1&post[user]=_why")
     #     #=> {'post' => {'id' => '1', 'user' => '_why'}}
     #
-    def qs_parse(qs, d = '&;')
+    def qsp(qs, d='&;', y=nil, z=H[])
         m = proc {|_,o,n|o.u(n,&m)rescue([*o]<<n)}
         (qs||'').
             split(/[#{d}] */n).
-            inject(H[]) { |h,p| k, v=un(p).split('=',2)
+            inject((b,z=z,H[])[0]) { |h,p| k, v=un(p).split('=',2)
                 h.u(k.split(/[\]\[]+/).reverse.
-                    inject(v) { |x,i| H[i,x] },&m)
+                    inject(y||v) { |x,i| H[i,x] },&m)
             } 
     end
 
     # Parses a string of cookies from the <tt>Cookie</tt> header.
-    def kp(s); c = qs_parse(s, ';,'); end
+    def kp(s); c = qsp(s, ';,'); end
 
     # Fields a request through Camping.  For traditional CGI applications, the method can be
     # executed without arguments.
@@ -661,7 +661,7 @@
       X.M
       k,a=X.D un("/#{e['PATH_INFO']}".gsub(/\/+/,'/'))
       k.new(r,e,(m=e['REQUEST_METHOD']||"GET")).Y.service *a
-    rescue Exception=>x
+    rescue Object=>x
       X::ServerError.new(r,e,'get').service(k,m,x)
     end
 
--- camping-o/lib/camping.rb	2006-12-20 23:38:16.000000000 -0700
+++ camping-r168/lib/camping.rb	2006-12-20 23:37:03.000000000 -0700
@@ -12,15 +12,15 @@
 merge!h;@body=b end;def redirect*a;r 302,'','Location'=>URL(*a)end;Z="\r\n"
 def initialize r,e,m;e=H[e.to_hash];@status,@method,@env,@headers,@root=200,m.
 downcase,e,{'Content-Type'=>"text/html"},e.SCRIPT_NAME.sub(/\/$/,'')
-@k=C.kp e.HTTP_COOKIE;q=C.qs_parse e.QUERY_STRING;@in=r
+@k=C.kp e.HTTP_COOKIE;q=C.qsp e.QUERY_STRING;@in=r
 if%r|\Amultipart/form-.*boundary=\"?([^\";,]+)|n.match e.CONTENT_TYPE
 b=/(?:\r?\n|\A)#{Regexp::quote("--#$1")}(?:--)?\r$/;until@in.eof?;fh=H[];for l in@in
 case l;when Z;break;when/^Content-D.+?: form-data;/;fh.u H[*$'.
 scan(/(?:\s(\w+)="([^"]+)")/).flatten];when/^Content-Type: (.+?)(\r$|\Z)/m;fh[
 :type]=$1;end;end;fn=fh[:name];o=if fh[:filename];o=fh[:tempfile]=Tempfile.new(:C)
 o.binmode;else;fh=""end;while l=@in.read(16384);if l=~b;o<<$`.chomp;@in.seek(-$'.
-size,IO::SEEK_CUR);break;end;o<<l;end;q[fn]=fh if fn;fh[:tempfile].rewind if
-fh.is_a?H;end;elsif@method=="post";q.u C.qs_parse(@in.read)end;@cookies,@input=
+size,IO::SEEK_CUR);break;end;o<<l;end;C.qsp(fn,'&;',fh,q) if fn;fh[:tempfile].rewind if
+fh.is_a?H;end;elsif@method=="post";q.u C.qsp(@in.read)end;@cookies,@input=
 @k.dup,q.dup end;def service*a;@body=send(@method,*a)if respond_to?@method
 @headers["Set-Cookie"]=@cookies.map{|k,v|"#{k}=#{C.escape(v)}; path=#{self/'/'
 }"if v!=@k[k]}-[nil];self end;def to_s;"Status: #{@status}#{Z+@headers.map{|k,v|
@@ -36,12 +36,12 @@
 self;def goes m;eval S.gsub(/Camping/,m.to_s).gsub("A\pps=[]","Cam\ping::Apps<<\
 self"),TOPLEVEL_BINDING;end;def escape s;s.to_s.gsub(/[^ \w.-]+/n){'%'+($&.
 unpack('H2'*$&.size)*'%').upcase}.tr(' ','+')end;def un s;s.tr('+',' ').gsub(
-/%([\da-f]{2})/in){[$1].pack('H*')}end;def qs_parse q,d='&;';m=proc{|_,o,n|o.u(
-n,&m)rescue([*o]<<n)};q.to_s.split(/[#{d}] */n).inject(H[]){|h,p|k,v=un(p).
-split('=',2);h.u k.split(/[\]\[]+/).reverse.inject(v){|x,i|H[i,x]},&m}end;def
-kp s;c=qs_parse(s,';,')end;def run r=$stdin,e=ENV;X.M;k,a=X.D un("/#{e[
+/%([\da-f]{2})/in){[$1].pack('H*')}end;def qsp q,d='&;',y=nil,z=H[];m=proc{|_,o,n|o.u(
+n,&m)rescue([*o]<<n)};q.to_s.split(/[#{d}] */n).inject((b,z=z,H[])[0]){|h,p|k,v=un(p).
+split('=',2);h.u k.split(/[\]\[]+/).reverse.inject(y||v){|x,i|H[i,x]},&m}end;def
+kp s;c=qsp(s,';,')end;def run r=$stdin,e=ENV;X.M;k,a=X.D un("/#{e[
 'PATH_INFO']}".gsub(/\/+/,'/'));k.new(r,e,(m=e['REQUEST_METHOD']||"GET")).Y.
-service *a;rescue Exception=>x;X::ServerError.new(r,e,'get').service(k,m,x)end
+service *a;rescue Object=>x;X::ServerError.new(r,e,'get').service(k,m,x)end
 def method_missing m,c,*a;X.M;k=X.const_get(c).new(StringIO.new,H['HTTP_HOST',
 '','SCRIPT_NAME','','HTTP_COOKIE',''],m.to_s);H.new(a.pop).each{|e,f|k.send(
 "#{e}=",f)}if Hash===a[-1];k.service *a;end;end;module Views;include X,Helpers
--- camping-o/lib/camping/fastcgi.rb	2006-12-20 23:36:46.000000000 -0700
+++ camping-r168/lib/camping/fastcgi.rb	2006-12-20 23:37:03.000000000 -0700
@@ -77,7 +77,7 @@
             begin
                 root, path = "/"
                 if ENV['FORCE_ROOT'] and ENV['FORCE_ROOT'].to_i == 1
-                  path = req.env['REQUEST_URI']
+                  path = req.env['SCRIPT_NAME']
                 else
                   root = req.env['SCRIPT_NAME']
                   path = req.env['PATH_INFO']
@@ -94,7 +94,7 @@
                 req.env['SCRIPT_NAME'] = File.join(root, dir)
                 req.env['PATH_INFO'] = path.gsub(/^#{dir}/, '')
 
-                controller = app.run(req.in, req.env)
+                controller = app.run(SeekStream.new(req.in), req.env)
                 sendfile = nil
                 headers = {}
                 controller.headers.each do |k, v|
@@ -194,5 +194,69 @@
         str.gsub(/&/n, '&amp;').gsub(/\"/n, '&quot;').gsub(/>/n, '&gt;').gsub(/</n, '&lt;')
     end
 
+    class SeekStream2
+        def initialize(stream)
+            @last_read = ""
+            @stream = stream
+        end
+        def eof?
+            @stream.eof?
+        end
+        def each
+            while( line = @stream.gets ) 
+                yield line
+            end
+        end
+        def read(len = 16384)
+            @last_read = @stream.read(len)
+        end
+        def seek(len, typ)
+            raise NotImplementedError, "only IO::SEEK_CUR is supported with SeekStream" if typ != IO::SEEK_CUR
+            raise NotImplementedError, "only rewinding is supported with SeekStream" if len > 0
+            raise NotImplementedError, "rewinding #{-len} past the buffer #{@last_read.size} start not supported with SeekStream" if -len > @last_read.size
+            -1.downto(len) { |x| @stream.ungetc(@last_read[x]) }
+            @last_read = ""
+            self
+        end
+    end
+
+    class SeekStream
+        def initialize(stream)
+            @last_read = ""
+            @stream = stream
+            @buffer = ""
+        end
+        def eof?
+            @buffer.empty? && @stream.eof?
+        end
+        def each
+            while true
+                pull(1024) until eof? or @buffer.index("\n")
+                return nil if eof?
+                yield @buffer.slice!(0..(@buffer.index("\n") || -1))
+            end
+        end
+        def pull(len)
+            @buffer += @stream.read(len).to_s
+        end
+        def read(len = 16384)
+            pull(len)
+            @last_read =
+                if eof?
+                    nil
+                else
+                    @buffer.slice!(0...len)
+                end
+        end
+        def seek(len, typ)
+            raise NotImplementedError, "only IO::SEEK_CUR is supported with SeekStream" if typ != IO::SEEK_CUR
+            raise NotImplementedError, "only rewinding is supported with SeekStream" if len > 0
+            raise NotImplementedError, "rewinding #{-len} past the buffer #{@last_read.size} start not supported with SeekStream" if -len > @last_read.size
+            @buffer = @last_read[len..-1] + @buffer
+            @last_read = ""
+            self
+        end
+    end
+
 end
 end
